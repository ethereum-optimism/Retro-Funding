import argparse
import sys
import os
import glob
import pandas as pd
from pathlib import Path

from .config import get_measurement_period_paths


def consolidate_rewards(season: str, measurement_period: str) -> pd.DataFrame:
    """
    Consolidate all rewards files generated by process_models.py into a single CSV.
    
    Args:
        season: The season number (e.g., '7', '8')
        measurement_period: The measurement period (e.g., 'M1', 'M2')
        
    Returns:
        Consolidated DataFrame with all rewards
    """
    # Get the outputs directory
    paths = get_measurement_period_paths(season, measurement_period)
    outputs_dir = paths['outputs']
    
    # Find all rewards files (files ending with _rewards.csv)
    rewards_files = glob.glob(os.path.join(outputs_dir, "*_rewards.csv"))
    
    if not rewards_files:
        print(f"No rewards files found in {outputs_dir}")
        return pd.DataFrame()
    
    # Process each file
    dfs = []
    for file_path in rewards_files:
        df = pd.read_csv(file_path)
        filename = os.path.basename(file_path)
        
        # Add metadata columns
        df['filename'] = filename
        df['season'] = season
        df['period'] = measurement_period
        
        # Rename allocated_amount to op_reward
        if 'allocated_amount' in df.columns:
            df = df.rename(columns={'allocated_amount': 'op_reward'})
        
        # Rename project_name to op_atlas_id
        if 'project_name' in df.columns:
            df = df.rename(columns={'project_name': 'op_atlas_id'})
        
        dfs.append(df)
    
    # Concatenate all DataFrames
    if dfs:
        consolidated = pd.concat(dfs, ignore_index=True)
        
        # Select and reorder columns
        columns = ['op_atlas_id', 'display_name', 'op_reward', 'filename', 'season', 'period']
        available_columns = [col for col in columns if col in consolidated.columns]
        
        consolidated = consolidated[available_columns]
        
        # Sort by op_atlas_id
        consolidated = consolidated.sort_values('op_atlas_id')
        
        return consolidated
    
    return pd.DataFrame()


def save_consolidated_rewards(df: pd.DataFrame, season: str, measurement_period: str) -> str:
    """
    Save the consolidated rewards DataFrame to a CSV file.
    
    Args:
        df: Consolidated rewards DataFrame
        season: The season number (e.g., '7', '8')
        measurement_period: The measurement period (e.g., 'M1', 'M2')
        
    Returns:
        Path to the saved file
    """
    # Get the outputs directory
    paths = get_measurement_period_paths(season, measurement_period)
    outputs_dir = paths['outputs']
    
    # Ensure output directory exists
    Path(outputs_dir).mkdir(parents=True, exist_ok=True)
    
    # Save to CSV
    output_path = os.path.join(outputs_dir, f"{measurement_period}_consolidated_rewards.csv")
    df.to_csv(output_path, index=False)
    
    return output_path


def main():
    """Main entry point for the rewards consolidation script."""
    parser = argparse.ArgumentParser(description='Consolidate rewards from process_models.py outputs')
    parser.add_argument('--season', '-s', type=str, required=True, choices=['7', '8'],
                       help='Season number (7 or 8)')
    parser.add_argument('--period', '-p', type=str, required=True,
                       help='Measurement period (e.g., M1, M2)')
    
    args = parser.parse_args()
    
    try:
        # Consolidate rewards
        df_consolidated = consolidate_rewards(args.season, args.period)
        
        if df_consolidated.empty:
            print("No rewards data to consolidate")
            return
        
        # Save consolidated rewards
        output_path = save_consolidated_rewards(df_consolidated, args.season, args.period)
        print(f"✓ Consolidated {len(df_consolidated)} rewards from {len(df_consolidated['filename'].unique())} files")
        print(f"✓ Saved to {output_path}")
        
    except Exception as e:
        print(f"Error: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()
